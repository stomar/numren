#!/usr/bin/env ruby
# == Name
#
# numren - rename files with numbered filenames
#
# == Description
#
# +numren+ renames files with a filename consisting of a number part
# and a name part separated by an underscore, like e.g. `01_Sample.txt'.
# Only the number part is changed, according to the given number.
#
# == See also
#
# Use <tt>numren --help</tt> to display a brief help message.
#
# The full documentation for +numren+ is available on the
# project home page.
#
# == Author
#
# Copyright (C) 2011-2013 Marcus Stollsteimer
#
# License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>

require 'optparse'

class String

  # Tests if string is a positive integer (padding with zeros is allowed).
  #
  # Returns +true+ if string is an integer.
  def is_i?
    /\A[+-]?[0-9]+\Z/ === self
  end
end

# This module contains the classes for the +numren+ tool.
module Numren

  PROGNAME  = 'numren'
  VERSION   = '1.0.0'
  DATE      = '2012-03-17'
  HOMEPAGE  = 'https://github.com/stomar/numren/'
  TAGLINE   = 'rename files with numbered filenames'

  COPYRIGHT = "Copyright (C) 2011-2013 Marcus Stollsteimer.\n" +
              "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n" +
              "This is free software: you are free to change and redistribute it.\n" +
              "There is NO WARRANTY, to the extent permitted by law."

  # The class for numbered filenames.
  # Instances must be initialized with a string containing
  # a valid filename of the form 'Number_Text', or else
  # an +ArgumentError+ is raised.
  class Filename

    # Initializes +Filename+ instances.
    #
    # +filename+ - a valid filename (an +ArgumentError+ may be raised)
    def initialize(filename)
      number_str, @name = split_filename(filename)
      @number = number_str.to_i
      @digits = number_str.size

      assert(@number && @name && @digits)
    end

    # Returns the numbered filename as string.
    def to_s
      "#{@number.to_s.rjust(@digits, '0')}_#{@name}"
    end

    # Sets the number part of the filename.
    # The number of digits is never decreased by this method, but
    # it might be increased to the necessary number of digits or
    # to the number of digits of the passed +number_str+.
    #
    # Raises a +RuntimeError+ if the new number part would be negative.
    #
    # Examples:
    #
    #   fn = Numren::Filename.new('01_Sample.txt')
    #   fn.number = '2'   and fn.to_s  # => 02_Sample.txt
    #   fn.number = '001' and fn.to_s  # => 001_Sample.txt
    #   fn.number = '+01' and fn.to_s  # => 002_Sample.txt
    #
    # +number_str+ - string with new number part of filename,
    #  like '42', '+5' or '-003'
    def number=(number_str)
      is_change = number_str =~ /\A[+-]/
      new_digits = number_str[/\d+/].size

      num = number_str.to_i
      new_number = is_change ? @number + num : num

      message = "`#{@number}' cannot be changed by #{num}."
      raise(RuntimeError, message, caller)  if new_number < 0

      @number = new_number
      self.digits = [new_digits, @number.to_s.size, @digits].max
    end

    # Sets number of digits if possible
    # (the number of digits cannot be less than that for the unpadded number).
    #
    # +digits+ - new number of digits
    def digits=(digits)
      @digits = digits  if digits >= @number.to_s.size
    end

    private

    # Splits a filename of the form `Number_Name' in its two parts.
    #
    # +filename+ - string of the form `number_name'
    #
    # Returns the array [number_str, name] or raises an
    # +ArgumentError+ if +filename+ is not of the form `number_name'.
    def split_filename(filename)
      unless /\A\d+_.+/ =~ filename
        raise(ArgumentError, "`#{filename}' not of the form `number_name'.",
              caller)
      end

      number_str, name = filename.split('_', 2)
      assert(filename == "#{number_str}_#{name}")

      [number_str, name]
    end

    # Fails when expression is not true.
    def assert(expression)
      fail 'assertion failure'  unless expression
    end
  end

  # Parser for the command line options.
  # The class method parse! does the job.
  class Optionparser

    # Parses the command line options from +argv+.
    # (+argv+ is cleared).
    # Might print out help or version information.
    #
    # +argv+ - array with the command line options
    #
    # Returns a hash containing the option parameters.
    def self.parse!(argv)

      options = {
        :files  => nil,
        :number => nil,
        :digits => nil
      }

      opt_parser = OptionParser.new do |opt|
        opt.banner = "Usage: #{PROGNAME} [options] file[s] number \n" +
                     "   or: #{PROGNAME} -d NUMBER file[s]"
        opt.separator ''
        opt.separator 'numren renames files with a filename consisting of a number part'
        opt.separator "and a name part separated by an underscore, like e.g. `01_Sample.txt'."
        opt.separator 'Only the number part is changed, according to the given number.'
        opt.separator ''
        opt.separator 'Options'
        opt.separator ''

        # process --version and --help first,
        # exit successfully (GNU Coding Standards)
        opt.on_tail('-h', '--help', 'Print a brief help message and exit.') do
          puts opt_parser
          puts "\nReport bugs on the #{PROGNAME} home page: <#{HOMEPAGE}>"
          exit
        end

        opt.on_tail('-v', '--version',
                    'Print a brief version information and exit.') do
          puts "#{PROGNAME} #{VERSION}"
          puts COPYRIGHT
          exit
        end

        opt.on('-d', '--digits NUMBER', Integer,
               'Rename the given files using NUMBER digits (if possible).') do |d|
          raise(OptionParser::InvalidArgument, d)  unless d > 0
          options[:digits] = d
        end

        opt.separator ''
      end
      opt_parser.parse!(argv)

      # check number of arguments left in argv and option argument values
      if !options[:digits]
        # only file[s] and number should be left (at least 2 arguments)
        raise(ArgumentError, 'wrong number of arguments')       if argv.size < 2
        raise(ArgumentError, 'last argument must be a number')  unless argv[-1].is_i?
        options[:number] = argv.pop
      else  # -d option set
        # only file[s] should be left (at least 1 argument)
        raise(ArgumentError, 'wrong number of arguments')       if argv.size < 1
      end

      options[:files]  = Array.new(argv)
      argv.clear

      options
    end
  end

  # The main program. It's run! method is called
  # if the script is run from the command line.
  # It parses the command line arguments and renames the files.
  class Application

    ERRORCODE = {:general => 1, :usage => 2}

    def initialize
      begin
        options = Optionparser.parse!(ARGV)
      rescue => e
        usage_fail(e.message)
      end
      @files = options[:files]
      @number = options[:number]
      @digits = options[:digits]
    end

    # The main program.
    def run!
      @files.each do |filename|
        unless File.exist?(filename)
          warn "There is no file `#{filename}'. (Skipped.)"
          next
        end

        # initialize filename
        begin
          fn = Filename.new(filename)
        rescue ArgumentError => e
          warn("#{e.message} (Skipped.)")
          next
        end

        # create new filename
        begin
          if @digits
            fn.digits = @digits
          else
            fn.number = @number
          end
        rescue RuntimeError => e
          warn("#{e.message} (Skipped.)")
          next
        end
        new_filename = fn.to_s

        if new_filename == filename
          warn("`#{filename}' and `#{new_filename}' are the same file. (Skipped.)")
          next
        end

        secure_rename(filename, new_filename)
      end   # of each
    end

    private

    def secure_rename(old_filename, new_filename)
      return  if File.exist?(new_filename) && !overwrite?(new_filename)

      warn "Moving from `#{old_filename}' to `#{new_filename}'."
      File.rename(old_filename, new_filename)
    end

    def overwrite?(filename)
      ask("File `#{filename}' already exists. Overwrite?")
    end

    # Asks for yes or no (y/n).
    #
    # +question+ - string to be printed
    #
    # Returns +true+ if the answer is yes.
    def ask(question)
      loop do
        $stderr.print "#{question} [y/n] "
        reply = $stdin.gets.chomp.downcase  # $stdin: avoids gets / ARGV problem
        return true   if reply == 'y'
        return false  if reply == 'n'
        warn "Please answer `y' or `n'."
      end
    end

    # Prints an error message and a short help information, then exits.
    def usage_fail(message)
      warn "#{PROGNAME}: #{message}"
      warn "Use `#{PROGNAME} --help' for valid options."
      exit ERRORCODE[:usage]
    end
  end

### call main method only if called on command line

if __FILE__ == $0
  Application.new.run!
end

end  # module
